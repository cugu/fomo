// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlc

import (
	"context"
	"time"
)

const article = `-- name: Article :one
SELECT id, guid, title, body, published_at, link, details, feed, read, bookmarked
FROM articles
WHERE id = ?1
`

func (q *Queries) Article(ctx context.Context, id int64) (Article, error) {
	row := q.db.QueryRowContext(ctx, article, id)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.Title,
		&i.Body,
		&i.PublishedAt,
		&i.Link,
		&i.Details,
		&i.Feed,
		&i.Read,
		&i.Bookmarked,
	)
	return i, err
}

const articleIDByGUID = `-- name: ArticleIDByGUID :one
SELECT id
FROM articles
WHERE guid = ?1
`

func (q *Queries) ArticleIDByGUID(ctx context.Context, guid string) (int64, error) {
	row := q.db.QueryRowContext(ctx, articleIDByGUID, guid)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const bookmarkArticle = `-- name: BookmarkArticle :exec
UPDATE articles
SET bookmarked = TRUE
WHERE id = ?1
`

func (q *Queries) BookmarkArticle(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, bookmarkArticle, id)
	return err
}

const commitSession = `-- name: CommitSession :exec
INSERT OR REPLACE INTO sessions (token, data, expiry)
VALUES (?1, ?2, ?3)
`

type CommitSessionParams struct {
	Token  interface{} `json:"token"`
	Data   []byte      `json:"data"`
	Expiry interface{} `json:"expiry"`
}

func (q *Queries) CommitSession(ctx context.Context, arg CommitSessionParams) error {
	_, err := q.db.ExecContext(ctx, commitSession, arg.Token, arg.Data, arg.Expiry)
	return err
}

const createArticle = `-- name: CreateArticle :one
INSERT OR IGNORE INTO articles (guid, title, body, published_at, link, feed, details, read, bookmarked)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)
RETURNING id
`

type CreateArticleParams struct {
	Guid        string    `json:"guid"`
	Title       string    `json:"title"`
	Body        string    `json:"body"`
	PublishedAt time.Time `json:"published_at"`
	Link        string    `json:"link"`
	Feed        string    `json:"feed"`
	Details     string    `json:"details"`
	Read        bool      `json:"read"`
	Bookmarked  bool      `json:"bookmarked"`
}

func (q *Queries) CreateArticle(ctx context.Context, arg CreateArticleParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createArticle,
		arg.Guid,
		arg.Title,
		arg.Body,
		arg.PublishedAt,
		arg.Link,
		arg.Feed,
		arg.Details,
		arg.Read,
		arg.Bookmarked,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE
FROM sessions
WHERE token = ?1
`

func (q *Queries) DeleteSession(ctx context.Context, token interface{}) error {
	_, err := q.db.ExecContext(ctx, deleteSession, token)
	return err
}

const findSession = `-- name: FindSession :one
SELECT token, data, expiry
FROM sessions
WHERE token = ?1
`

func (q *Queries) FindSession(ctx context.Context, token interface{}) (Session, error) {
	row := q.db.QueryRowContext(ctx, findSession, token)
	var i Session
	err := row.Scan(&i.Token, &i.Data, &i.Expiry)
	return i, err
}

const listArticles = `-- name: ListArticles :many
SELECT id, guid, title, body, published_at, link, details, feed, read, bookmarked
FROM articles
ORDER BY published_at DESC
LIMIT ?2 OFFSET ?1
`

type ListArticlesParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

func (q *Queries) ListArticles(ctx context.Context, arg ListArticlesParams) ([]Article, error) {
	rows, err := q.db.QueryContext(ctx, listArticles, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.Title,
			&i.Body,
			&i.PublishedAt,
			&i.Link,
			&i.Details,
			&i.Feed,
			&i.Read,
			&i.Bookmarked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookmarkedArticles = `-- name: ListBookmarkedArticles :many
SELECT id, guid, title, body, published_at, link, details, feed, read, bookmarked
FROM articles
WHERE bookmarked = TRUE
ORDER BY published_at DESC
LIMIT ?2 OFFSET ?1
`

type ListBookmarkedArticlesParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

func (q *Queries) ListBookmarkedArticles(ctx context.Context, arg ListBookmarkedArticlesParams) ([]Article, error) {
	rows, err := q.db.QueryContext(ctx, listBookmarkedArticles, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.Title,
			&i.Body,
			&i.PublishedAt,
			&i.Link,
			&i.Details,
			&i.Feed,
			&i.Read,
			&i.Bookmarked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReadArticles = `-- name: ListReadArticles :many
SELECT id, guid, title, body, published_at, link, details, feed, read, bookmarked
FROM articles
WHERE read = TRUE
ORDER BY published_at DESC
LIMIT ?2 OFFSET ?1
`

type ListReadArticlesParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

func (q *Queries) ListReadArticles(ctx context.Context, arg ListReadArticlesParams) ([]Article, error) {
	rows, err := q.db.QueryContext(ctx, listReadArticles, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.Title,
			&i.Body,
			&i.PublishedAt,
			&i.Link,
			&i.Details,
			&i.Feed,
			&i.Read,
			&i.Bookmarked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnreadArticles = `-- name: ListUnreadArticles :many
SELECT id, guid, title, body, published_at, link, details, feed, read, bookmarked
FROM articles
WHERE read = FALSE
ORDER BY published_at DESC
LIMIT ?2 OFFSET ?1
`

type ListUnreadArticlesParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

func (q *Queries) ListUnreadArticles(ctx context.Context, arg ListUnreadArticlesParams) ([]Article, error) {
	rows, err := q.db.QueryContext(ctx, listUnreadArticles, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.Title,
			&i.Body,
			&i.PublishedAt,
			&i.Link,
			&i.Details,
			&i.Feed,
			&i.Read,
			&i.Bookmarked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markReadAllArticles = `-- name: MarkReadAllArticles :exec
UPDATE articles
SET read = TRUE
WHERE read = FALSE
`

func (q *Queries) MarkReadAllArticles(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, markReadAllArticles)
	return err
}

const markReadArticle = `-- name: MarkReadArticle :exec
UPDATE articles
SET read = TRUE
WHERE id = ?1
`

func (q *Queries) MarkReadArticle(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markReadArticle, id)
	return err
}

const nextUnreadArticle = `-- name: NextUnreadArticle :one
SELECT id, guid, title, body, published_at, link, details, feed, read, bookmarked
FROM articles
WHERE read = FALSE
ORDER BY published_at DESC
LIMIT 1
`

func (q *Queries) NextUnreadArticle(ctx context.Context) (Article, error) {
	row := q.db.QueryRowContext(ctx, nextUnreadArticle)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.Title,
		&i.Body,
		&i.PublishedAt,
		&i.Link,
		&i.Details,
		&i.Feed,
		&i.Read,
		&i.Bookmarked,
	)
	return i, err
}

const setArticle = `-- name: SetArticle :one
INSERT OR REPLACE INTO articles (guid, title, body, published_at, link, feed, details, read, bookmarked)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)
RETURNING id
`

type SetArticleParams struct {
	Guid        string    `json:"guid"`
	Title       string    `json:"title"`
	Body        string    `json:"body"`
	PublishedAt time.Time `json:"published_at"`
	Link        string    `json:"link"`
	Feed        string    `json:"feed"`
	Details     string    `json:"details"`
	Read        bool      `json:"read"`
	Bookmarked  bool      `json:"bookmarked"`
}

func (q *Queries) SetArticle(ctx context.Context, arg SetArticleParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, setArticle,
		arg.Guid,
		arg.Title,
		arg.Body,
		arg.PublishedAt,
		arg.Link,
		arg.Feed,
		arg.Details,
		arg.Read,
		arg.Bookmarked,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const unbookmarkArticle = `-- name: UnbookmarkArticle :exec
UPDATE articles
SET bookmarked = FALSE
WHERE id = ?1
`

func (q *Queries) UnbookmarkArticle(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, unbookmarkArticle, id)
	return err
}
